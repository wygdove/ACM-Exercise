1001 Alice and Bob
两个人的坐标系不同，如果都走到（x，y）能够碰面的话，只有一种可能：在广场矩形的中心位置。
即： 2*x == N 并且 2*y == M。

1002 Bob and math problem
题目要求将N个数字（每个数字都是0...9）组合成一个整数。
满足以下三个条件：
	[1] 这个整数是一个奇数；
	[2] 且没有前导0；
	[3] 找出最大的那个满足[1][2]条件的奇数。
解法：
	贪心策略。
	1、先对这N个数字从大到小排序，得到的序列是一个最大的整数（但它可能还不是奇数）。
	2、然后找到最小的一个奇数数字，放到最后一位，即可得到我们所求的最大奇数了。如:"98764" --> "98647"。
	3、请注意前导零的情况。如:"900" --> "009" 就非法了，应该输出-1。

1003 Boring count
枚举字符串下标i，每次计算以i为结尾的符合条件的最长串。那么以i为结尾的符合条件子串个数就是最长串的长度。求和即可。
计算以i为结尾的符合条件的最长串两种方法：
1.维护一个起点下标startPos，初始为1。如果当前为i，那么cnt[str[i]]++，如果大于k的话，就while( str[startPos] != str[i+1] ) cnt[str[startPos]]--, startPos++; 每次都保证 startPos~i区间每个字母个数都不超过k个。ans += ( i-startPos+1 )。 时间复杂度O(n)
2.预处理出所有字母的前缀和。然后通过二分找出以i为结尾的符合条件的最长串的左边界。时间复杂度O(nlogn)，写的不够好的可能超时。

1004 Argestes and Sequence
方法一：
可以分块统计，块节点内数据：cnt[d][p]：d位为p的数字个数，num[i]：记录数字。
时间复杂度O(n * sqrt(n))

方法二：
离线算法：读取全部的操作，将更新与询问操作别分存起来，并且询问操作位数不同的位也分别存起来，即开长度为10的数组，分别存1~10的询问，更新操作统一存起来就好了，操作的先后顺序不要变。
用树状数组维护每一位的区间和。
然后遍历1~10位，对于当前位遍历当前位的询问操作，对于每个询问 在询问之前要把该询问操作之前的更新操作插到树状数组中。
